const n={active:!0,breakpoints:{},snapped:"is-snapped",inView:"is-in-view",draggable:"is-draggable",dragging:"is-dragging",loop:"is-loop"};function o(n){return(Array.isArray(n)?n:[n]).filter(Boolean)}function i(n,o){n&&o.length&&n.classList.remove(...o)}function e(n,o){n&&o.length&&n.classList.add(...o)}function a(r={}){let s,t,g,l,p=[],d=[];const c=["select"],f=["pointerDown","pointerUp"],u=["slidesInView"],w={snapped:[],inView:[],draggable:[],dragging:[],loop:[]};function b(n,o){("pointerDown"===o?e:i)(g,w.dragging)}function h(n=[],o=[],a){const r=o.map(n=>l[n]),s=n.map(n=>l[n]);return r.forEach(n=>i(n,a)),s.forEach(n=>e(n,a)),n}function E(){const{slideRegistry:n}=t.internalEngine(),o=n[t.selectedScrollSnap()];p=h(o,p,w.snapped)}function V(){const n=t.slidesInView();d=h(n,d,w.inView)}return{name:"classNames",options:r,init:function(i,p){t=i;const{mergeOptions:d,optionsAtMedia:h}=p,m=d(n,a.globalOptions),y=d(m,r);s=h(y),g=t.rootNode(),l=t.slideNodes();const{watchDrag:v,loop:O}=t.internalEngine().options,A=!!v;s.loop&&O&&(w.loop=o(s.loop),e(g,w.loop)),s.draggable&&A&&(w.draggable=o(s.draggable),e(g,w.draggable)),s.dragging&&(w.dragging=o(s.dragging),f.forEach(n=>t.on(n,b))),s.snapped&&(w.snapped=o(s.snapped),c.forEach(n=>t.on(n,E)),E()),s.inView&&(w.inView=o(s.inView),u.forEach(n=>t.on(n,V)),V())},destroy:function(){f.forEach(n=>t.off(n,b)),c.forEach(n=>t.off(n,E)),u.forEach(n=>t.off(n,V)),i(g,w.loop),i(g,w.draggable),i(g,w.dragging),h([],p,w.snapped),h([],d,w.inView),Object.keys(w).forEach(n=>{w[n]=[]})}}}a.globalOptions=void 0;export{a as default};
