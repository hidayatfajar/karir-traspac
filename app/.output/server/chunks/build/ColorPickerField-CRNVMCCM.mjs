import { f as fn } from './Popover-BMuqDJoE.mjs';
import { v as Wt$1, s as pm, _ as Ob, u as da, t as Ky, w as Xm, m as Ym, P as _m } from './server.mjs';
import { m as m$1 } from './index-yQmnmHk3.mjs';
import { o } from './_plugin-vue_export-helper-BCo6x5W8.mjs';
import '../_/nitro.mjs';
import 'crypto-es';
import 'node:http';
import 'node:https';
import 'node:events';
import 'node:buffer';
import 'node:fs';
import 'node:url';
import '@iconify/utils';
import 'node:crypto';
import 'consola';
import 'node:path';
import './useForwardPropsEmits-nQnKVeqj.mjs';
import './usePrimitiveElement-BYq1qwBL.mjs';
import './ConfigProvider-BpvNyuo1.mjs';
import './useDirection-D0ypspbM.mjs';
import './useKbd-kRIii9yh.mjs';
import './PopperArrow-DHFd-Rdx.mjs';
import './useGraceArea-CDtlyMEy.mjs';
import './usePortal-B0EwXMSu.mjs';
import './Presence-D-YonBfP.mjs';
import './useBodyScrollLock-DClI9ev0.mjs';
import './getActiveElement-CxMYnBFR.mjs';
import './useFocusGuards-AjDOEN6x.mjs';
import './nullish-aV-w2MPu.mjs';
import 'node:zlib';
import 'node:stream';
import 'node:util';
import 'node:net';
import 'util';
import 'stream';
import 'path';
import 'http';
import 'https';
import 'url';
import 'fs';
import 'crypto';
import 'assert';
import 'tty';
import 'node:process';
import 'node:os';
import 'node:tty';
import 'zlib';
import 'events';
import '../routes/renderer.mjs';
import 'vue-bundle-renderer/runtime';
import 'vue/server-renderer';
import 'unhead/server';
import 'devalue';
import 'unhead/plugins';
import 'unhead/utils';
import 'vue';

const h = 255, d = 100, m = 125, A = 150;
var b, p, g, H, C;
(C = b || (b = {})).HEX = "HEX", C.RGB = "RGB", C.HWB = "HWB", C.HSL = "HSL", C.CIELab = "CIELab", C.LCH = "LCH", C.CMYK = "CMYK", function(t2) {
  t2.ANALOGOUS = "ANALOGOUS", t2.COMPLEMENTARY = "COMPLEMENTARY", t2.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY", t2.TRIADIC = "TRIADIC", t2.TETRADIC = "TETRADIC", t2.SQUARE = "SQUARE";
}(p || (p = {})), function(t2) {
  t2.ADDITIVE = "ADDITIVE", t2.SUBTRACTIVE = "SUBTRACTIVE";
}(g || (g = {})), function(t2) {
  t2.black = "#000000", t2.silver = "#C0C0C0", t2.gray = "#808080", t2.white = "#FFFFFF", t2.maroon = "#800000", t2.red = "#FF0000", t2.purple = "#800080", t2.fuchsia = "#FF00FF", t2.green = "#008000", t2.lime = "#00FF00", t2.olive = "#808000", t2.yellow = "#FFFF00", t2.navy = "#000080", t2.blue = "#0000FF", t2.teal = "#008080", t2.aqua = "#00FFFF", t2.orange = "#FFA500", t2.aliceblue = "#F0F8FF", t2.antiquewhite = "#FAEBD7", t2.aquamarine = "#7FFFD4", t2.azure = "#F0FFFF", t2.beige = "#F5F5DC", t2.bisque = "#FFE4C4", t2.blanchedalmond = "#FFEBCD", t2.blueviolet = "#8A2BE2", t2.brown = "#A52A2A", t2.burlywood = "#DEB887", t2.cadetblue = "#5F9EA0", t2.chartreuse = "#7FFF00", t2.chocolate = "#D2691E", t2.coral = "#FF7F50", t2.cornflowerblue = "#6495ED", t2.cornsilk = "#FFF8DC", t2.crimson = "#DC143C", t2.cyan = "#00FFFF", t2.darkblue = "#00008B", t2.darkcyan = "#008B8B", t2.darkgoldenrod = "#B8860B", t2.darkgray = "#A9A9A9", t2.darkgreen = "#006400", t2.darkgrey = "#A9A9A9", t2.darkkhaki = "#BDB76B", t2.darkmagenta = "#8B008B", t2.darkolivegreen = "#556B2F", t2.darkorange = "#FF8C00", t2.darkorchid = "#9932CC", t2.darkred = "#8B0000", t2.darksalmon = "#E9967A", t2.darkseagreen = "#8FBC8F", t2.darkslateblue = "#483D8B", t2.darkslategray = "#2F4F4F", t2.darkslategrey = "#2F4F4F", t2.darkturquoise = "#00CED1", t2.darkviolet = "#9400D3", t2.deeppink = "#FF1493", t2.deepskyblue = "#00BFFF", t2.dimgray = "#696969", t2.dimgrey = "#696969", t2.dodgerblue = "#1E90FF", t2.firebrick = "#B22222", t2.floralwhite = "#FFFAF0", t2.forestgreen = "#228B22", t2.gainsboro = "#DCDCDC", t2.ghostwhite = "#F8F8FF", t2.gold = "#FFD700", t2.goldenrod = "#DAA520", t2.greenyellow = "#ADFF2F", t2.grey = "#808080", t2.honeydew = "#F0FFF0", t2.hotpink = "#FF69B4", t2.indianred = "#CD5C5C", t2.indigo = "#4B0082", t2.ivory = "#FFFFF0", t2.khaki = "#F0E68C", t2.lavender = "#E6E6FA", t2.lavenderblush = "#FFF0F5", t2.lawngreen = "#7CFC00", t2.lemonchiffon = "#FFFACD", t2.lightblue = "#ADD8E6", t2.lightcoral = "#F08080", t2.lightcyan = "#E0FFFF", t2.lightgoldenrodyellow = "#FAFAD2", t2.lightgray = "#D3D3D3", t2.lightgreen = "#90EE90", t2.lightgrey = "#D3D3D3", t2.lightpink = "#FFB6C1", t2.lightsalmon = "#FFA07A", t2.lightseagreen = "#20B2AA", t2.lightskyblue = "#87CEFA", t2.lightslategray = "#778899", t2.lightslategrey = "#778899", t2.lightsteelblue = "#B0C4DE", t2.lightyellow = "#FFFFE0", t2.limegreen = "#32CD32", t2.linen = "#FAF0E6", t2.magenta = "#FF00FF", t2.mediumaquamarine = "#66CDAA", t2.mediumblue = "#0000CD", t2.mediumorchid = "#BA55D3", t2.mediumpurple = "#9370DB", t2.mediumseagreen = "#3CB371", t2.mediumslateblue = "#7B68EE", t2.mediumspringgreen = "#00FA9A", t2.mediumturquoise = "#48D1CC", t2.mediumvioletred = "#C71585", t2.midnightblue = "#191970", t2.mintcream = "#F5FFFA", t2.mistyrose = "#FFE4E1", t2.moccasin = "#FFE4B5", t2.navajowhite = "#FFDEAD", t2.oldlace = "#FDF5E6", t2.olivedrab = "#6B8E23", t2.orangered = "#FF4500", t2.orchid = "#DA70D6", t2.palegoldenrod = "#EEE8AA", t2.palegreen = "#98FB98", t2.paleturquoise = "#AFEEEE", t2.palevioletred = "#DB7093", t2.papayawhip = "#FFEFD5", t2.peachpuff = "#FFDAB9", t2.peru = "#CD853F", t2.pink = "#FFC0CB", t2.plum = "#DDA0DD", t2.powderblue = "#B0E0E6", t2.rosybrown = "#BC8F8F", t2.royalblue = "#4169E1", t2.saddlebrown = "#8B4513", t2.salmon = "#FA8072", t2.sandybrown = "#F4A460", t2.seagreen = "#2E8B57", t2.seashell = "#FFF5EE", t2.sienna = "#A0522D", t2.skyblue = "#87CEEB", t2.slateblue = "#6A5ACD", t2.slategray = "#708090", t2.slategrey = "#708090", t2.snow = "#FFFAFA", t2.springgreen = "#00FF7F", t2.steelblue = "#4682B4", t2.tan = "#D2B48C", t2.thistle = "#D8BFD8", t2.tomato = "#FF6347", t2.turquoise = "#40E0D0", t2.violet = "#EE82EE", t2.wheat = "#F5DEB3", t2.whitesmoke = "#F5F5F5", t2.yellowgreen = "#9ACD32", t2.rebeccapurple = "#663399";
}(H || (H = {}));
const L = Object.keys(H), B = { HEX: ["R", "G", "B", "A"], RGB: ["R", "G", "B", "A"], HSL: ["H", "S", "L", "A"], HWB: ["H", "W", "B", "A"], CIELab: ["L", "a", "b", "A"], LCH: ["L", "C", "H", "A"], CMYK: ["C", "M", "Y", "K", "A"] }, E = { ABGR: b.RGB, ABHW: b.HWB, ACHL: b.LCH, ACKMY: b.CMYK, AHLS: b.HSL, ALAB: b.CIELab, BGR: b.RGB, BHW: b.HWB, CHL: b.LCH, CKMY: b.CMYK, HLS: b.HSL, LAB: b.CIELab };
var f;
!function(t2) {
  t2.NUMBER = "number", t2.BOOLEAN = "boolean";
}(f || (f = {}));
const F = { [b.HEX]: /^#(?:(?<r>[a-f\d])(?<g>[a-f\d])(?<b>[a-f\d])(?<a>[a-f\d])?|(?<rr>[a-f\d]{2})(?<gg>[a-f\d]{2})(?<bb>[a-f\d]{2})(?<aa>[a-f\d]{2})?)$/i, [b.RGB]: /^rgba?\s*\(\s*(?:(?<r_legacy>(?:\d*\.)?\d+%?)\s*,\s*(?<g_legacy>(?:\d*\.)?\d+%?)\s*,\s*(?<b_legacy>(?:\d*\.)?\d+%?)(?:\s*,\s*(?<a_legacy>(?:\d*\.)?\d+))?|(?<r>(?:\d*\.)?\d+%?)\s+(?<g>(?:\d*\.)?\d+%?)\s+(?<b>(?:\d*\.)?\d+%?)(?:\s*\/\s*(?<a>(?:\d*\.)?\d+%?))?|from\s+(?<from>(?:\w+|\w+\(\s*[^())]+\s*\)|\w+\(from\s+\w+\(.*\)\s*\)|#[a-fA-F\d]+))\s+(?<relative_r>(?:[rgb]|(?:\d*\.)?\d+|calc\([rgb()/*\-+\d.\s]+\)))\s+(?<relative_g>(?:[rgb]|(?:\d*\.)?\d+|calc\([rgb()/*\-+\d.\s]+\)))\s+(?<relative_b>(?:[rgb]|(?:\d*\.)?\d+|calc\([rgb()/*\-+\d.\s]+\)))(?:\s*\/\s*(?<relative_a>(?:(?:\d*\.)?\d+%?|calc\([()/*\-+\d.\s\w]*(?:alpha)?[()/*\-+\d.\s\w]*\)|alpha)))?)\s*\)$/, [b.HWB]: /^hwb\s*\(\s*(?:(?<h>(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s+(?<w>(?:\d*\.)?\d+)%\s+(?<b>(?:\d*\.)?\d+)%(?:\s*\/\s*(?<a>(?:\d*\.)?\d+%?))?|from\s+(?<from>(?:\w+|\w+\(\s*[^())]+\s*\)|\w+\(from\s+\w+\(.*\)\s*\)|#[a-fA-F\d]+))\s+(?<relative_h>(?:[hwb]|(?:\d*\.)?\d+|calc\([hwb()/*\-+\d.\s]+\)))\s+(?<relative_w>(?:[hwb]|(?:\d*\.)?\d+|calc\([hwb()/*\-+\d.\s]+\)))%?\s+(?<relative_b>(?:[hwb]|(?:\d*\.)?\d+|calc\([hwb()/*\-+\d.\s]+\)))%?(?:\s*\/\s*(?<relative_a>(?:(?:\d*\.)?\d+%?|calc\([()/*\-+\d.\s\w]*(?:alpha)?[()/*\-+\d.\s\w]*\)|alpha)))?)\s*\)$/, [b.HSL]: /^hsla?\s*\(\s*(?:(?<h_legacy>-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*,\s*(?<s_legacy>(?:\d*\.)?\d+)%\s*,\s*(?<l_legacy>(?:\d*\.)?\d+)%(?:\s*,\s*(?<a_legacy>(?:\d*\.)?\d+))?|(?<h>-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s+(?<s>(?:\d*\.)?\d+)%?\s+(?<l>(?:\d*\.)?\d+)%?(?:\s*\/\s*(?<a>(?:\d*\.)?\d+%?))?|from\s+(?<from>(?:\w+|\w+\(\s*[^())]+\s*\)|\w+\(from\s+\w+\(.*\)\s*\)|#[a-fA-F\d]+))\s+(?<relative_h>(?:[hsl]|(?:\d*\.)?\d+|calc\([hsl()/*\-+\d.\s]+\)))\s+(?<relative_s>(?:[hsl]|(?:\d*\.)?\d+|calc\([hsl()/*\-+\d.\s]+\)))%?\s+(?<relative_l>(?:[hsl]|(?:\d*\.)?\d+|calc\([hsl()/*\-+\d.\s]+\)))%?(?:\s*\/\s*(?<relative_a>(?:(?:\d*\.)?\d+%?|calc\([()/*\-+\d.\s\w]*(?:alpha)?[()/*\-+\d.\s\w]*\)|alpha)))?)\s*\)$/, [b.CIELab]: /^lab\s*\(\s*(?:(?<L>(?:\d*\.)?\d+%?)\s+(?<a>-?(?:\d*\.)?\d+%?)\s+(?<b>-?(?:\d*\.)?\d+%?)(?:\s*\/\s*(?<A>(?:\d*\.)?\d+%?))?|from\s+(?<from>(?:\w+|\w+\(\s*[^())]+\s*\)|\w+\(from\s+\w+\(.*\)\s*\)|#[a-fA-F\d]+))\s+(?<relative_L>(?:[lab]|(?:\d*\.)?\d+|calc\([lab()/*\-+\d.\s]+\)))\s+(?<relative_a>(?:[lab]|(?:\d*\.)?\d+|calc\([lab()/*\-+\d.\s]+\)))\s+(?<relative_b>(?:[lab]|(?:\d*\.)?\d+|calc\([lab()/*\-+\d.\s]+\)))(?:\s*\/\s*(?<relative_A>(?:(?:\d*\.)?\d+%?|calc\([()/*\-+\d.\s\w]*(?:alpha)?[()/*\-+\d.\s\w]*\)|alpha)))?)\s*\)$/, [b.LCH]: /^lch\s*\(\s*(?:(?<l>(?:\d*\.)?\d+%?)\s+(?<c>-?(?:\d*\.)?\d+%?)\s+(?<h>-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)(?:\s*\/\s*(?<a>(?:\d*\.)?\d+%?))?|from\s+(?<from>(?:\w+|\w+\(\s*[^())]+\s*\)|\w+\(from\s+\w+\(.*\)\s*\)|#[a-fA-F\d]+))\s+(?<relative_l>(?:[lch]|(?:\d*\.)?\d+|calc\([lch()/*\-+\d.\s]+\)))\s+(?<relative_c>(?:[lch]|(?:\d*\.)?\d+|calc\([lch()/*\-+\d.\s]+\)))\s+(?<relative_h>(?:[lch]|(?:\d*\.)?\d+|calc\([lch()/*\-+\d.\s]+\)))(?:\s*\/\s*(?<relative_a>(?:(?:\d*\.)?\d+%?|calc\([()/*\-+\d.\s\w]*(?:alpha)?[()/*\-+\d.\s\w]*\)|alpha)))?)\s*\)$/, [b.CMYK]: /^(?:device-cmyk|cmyk)\s*\(\s*(?:(?<c_legacy>(?:\d*\.)?\d+%?)\s*,\s*(?<m_legacy>(?:\d*\.)?\d+%?)\s*,\s*(?<y_legacy>(?:\d*\.)?\d+%?)\s*,\s*(?<k_legacy>(?:\d*\.)?\d+%?)(?:\s*,\s*(?<a_legacy>(?:\d*\.)?\d+))?|(?<c>(?:\d*\.)?\d+%?)\s+(?<m>(?:\d*\.)?\d+%?)\s+(?<y>(?:\d*\.)?\d+%?)\s+(?<k>(?:\d*\.)?\d+%?)(?:\s*\/\s*(?<a>(?:\d*\.)?\d+%?))?)\s*\)$/ }, R = { REGEXP: /^calc\(\s*(?<operation>[\d./*+-\w\s]+)\s*\)$/, SCOPED: /\(\s*([^()]+)\s*\)/g, DIVISION: /\s*(?<left>(?:(?:\d*\.)?\d+|\w+))\s*\/\s*(?<right>(?:(?:\d*\.)?\d+|\w+))\s*/, MULTIPLICATION: /\s*(?<left>(?:(?:\d*\.)?\d+|\w+))\s*\*\s*(?<right>(?:(?:\d*\.)?\d+|\w+))\s*/, SUM: /\s*(?<left>(?:(?:\d*\.)?\d+|\w+))\s*\+\s*(?<right>(?:(?:\d*\.)?\d+|\w+))\s*/, REST: /\s*(?<left>(?:(?:\d*\.)?\d+|\w+))\s*-\s*(?<right>(?:(?:\d*\.)?\d+|\w+))\s*/ }, _ = /^(?<number>-?(?:\d*\.)?\d+)(?<units>(?:deg|grad|rad|turn)?)$/, S = /^(-?\d+(?:\.\d+)?|-?\.\d+)%$/, y = /^0x([a-f\d]{1,2})$/i, v = /\{(\d+)\}/g, G = /,( +|\d+)/g, M = / +/;
var k, w, I;
!function(t2) {
  t2.NONE = "none", t2.DEGREES = "deg", t2.GRADIANS = "grad", t2.RADIANS = "rad", t2.TURNS = "turn";
}(k || (k = {})), function(t2) {
  t2.NONE = "none", t2.PERCENT = "percent";
}(w || (w = {})), function(t2) {
  t2.DEVICE_CMYK = "device-cmyk", t2.CMYK = "cmyk";
}(I || (I = {}));
const P = { decimals: 6, legacyCSS: false, spacesAfterCommas: false, anglesUnit: k.NONE, rgbUnit: w.NONE, labUnit: w.NONE, lchUnit: w.NONE, cmykUnit: w.PERCENT, alphaUnit: w.NONE, cmykFunction: I.DEVICE_CMYK }, O = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), x = (t2) => +`${t2}`.replace(S, "$1"), j = (t2) => S.test(`${t2}`) ? x(t2) : Math.min(+t2, 100), D = (t2) => (1 === t2.length && (t2 += t2), parseInt(t2, 16)), $ = (t2) => {
  const e2 = U(t2, 0).toString(16).toUpperCase();
  return 1 === e2.length ? `0x0${e2}` : `0x${e2}`;
}, W = (t2, e2 = false) => !e2 && S.test(t2) ? Math.min(h * x(t2) / 100, h) : y.test(t2) ? (3 === t2.length && (t2 += t2.slice(-1)), e2 ? U(t2) / h : U(t2)) : Math.min(+t2, e2 ? 1 : h), N = (t2) => S.test(t2) ? V(m * x(t2) / 100, -125, m) : V(+t2, -125, m), T = (t2) => S.test(t2) ? V(A * x(t2) / 100, -150, A) : V(+t2, -150, A), X = (t2) => Math.min(S.test(t2) ? x(t2) / 100 : +t2, 1), Y = (t2) => [...t2].sort().join("").toUpperCase(), U = (t2, e2 = 6) => {
  const s2 = Math.pow(10, e2);
  return Math.round(+t2 * s2) / s2;
}, V = (t2, e2, s2) => Math.max(e2, Math.min(t2, s2)), K = (t2) => 180 * t2 / Math.PI, z = (t2) => t2 * Math.PI / 180, q = 360, Q = (t2) => {
  if ("string" == typeof t2) {
    const e2 = t2.match(_).groups, s2 = +e2.number;
    switch (e2.units) {
      case k.RADIANS:
        t2 = U(K(s2));
        break;
      case k.TURNS:
        t2 = U(s2 * q);
        break;
      case k.GRADIANS:
        t2 = U(0.9 * s2);
        break;
      case k.DEGREES:
      default:
        t2 = s2;
    }
  }
  return (t2 > 360 || t2 < 0) && (t2 -= Math.floor(t2 / q) * q), t2;
}, Z = (t2) => ("string" == typeof t2 && (t2 = S.test(t2) ? x(t2) / 100 : +t2), isNaN(+t2) || t2 > 1 ? 1 : U(t2)), J = (t2, e2) => {
  let s2;
  switch (e2) {
    case k.RADIANS:
      s2 = U(z(t2));
      break;
    case k.TURNS:
      s2 = U(t2 / q);
      break;
    case k.GRADIANS:
      s2 = U(10 / 9 * t2);
      break;
    case k.DEGREES:
    case k.NONE:
    default:
      s2 = t2;
  }
  return s2;
}, tt = (t2) => `${t2}` in g, et = [[0.4360747, 0.3850649, 0.1430804], [0.2225045, 0.7168786, 0.0606169], [0.0139322, 0.0971045, 0.7141733]], st = [[3.1338561, -1.6168667, -0.4906146], [-0.9787684, 1.9161415, 0.033454], [0.0719453, -0.2289914, 1.4052427]], rt = et.map((t2) => t2.reduce((t3, e2) => t3 + e2, 0)), at = (t2, e2, s2) => (s2 < 0 && (s2 += 6), s2 >= 6 && (s2 -= 6), U(s2 < 1 ? ((e2 - t2) * s2 + t2) * h : s2 < 3 ? e2 * h : s2 < 4 ? ((e2 - t2) * (4 - s2) + t2) * h : t2 * h)), it = (t2) => t2 <= 0.04045 ? t2 / 12.92 : ((t2 + 0.055) / 1.055) ** 2.4, nt = (t2) => t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * t2 ** (1 / 2.4) - 0.055, ot = (t2, e2, s2, r2) => {
  const a2 = [0, 0, 0], i2 = [t2, e2, s2];
  return r2.forEach((t3, e3) => {
    t3.forEach((t4, s3) => {
      a2[e3] += t4 * i2[s3];
    });
  }), a2;
}, ct = (t2, e2, s2) => {
  e2 /= 100;
  const r2 = (s2 /= 100) <= 0.5 ? s2 * (e2 + 1) : s2 + e2 - s2 * e2, a2 = 2 * s2 - r2;
  return { R: at(a2, r2, 2 + (t2 /= 60)), G: at(a2, r2, t2), B: at(a2, r2, t2 - 2) };
}, lt = (t2, e2, s2, r2 = 1) => {
  t2 /= h, e2 /= h, s2 /= h, r2 = Math.min(r2, 1);
  const a2 = Math.max(t2, e2, s2), i2 = Math.min(t2, e2, s2), n2 = a2 - i2;
  let o2 = 0, c2 = 0;
  const l2 = (a2 + i2) / 2;
  if (0 !== n2) {
    switch (a2) {
      case t2:
        o2 = (e2 - s2) / n2 % 6;
        break;
      case e2:
        o2 = (s2 - t2) / n2 + 2;
        break;
      case s2:
        o2 = (t2 - e2) / n2 + 4;
    }
    o2 = U(60 * o2), o2 < 0 && (o2 += 360), c2 = n2 / (1 - Math.abs(2 * l2 - 1));
  }
  return { H: o2, S: U(100 * c2), L: U(100 * l2), A: r2 };
}, ut = (t2, e2, s2) => {
  const r2 = [t2 / h, e2 / h, s2 / h].map(it), a2 = ot(r2[0], r2[1], r2[2], et), i2 = ((t3, e3, s3) => {
    const r3 = (t4) => t4 > (6 / 29) ** 3 ? Math.cbrt(t4) : t4 / (3 * (6 / 29) ** 2) + 4 / 29, a3 = r3(t3 / rt[0]), i3 = r3(e3 / rt[1]);
    return [116 * i3 - 16, 500 * (a3 - i3), 200 * (i3 - r3(s3 / rt[2]))];
  })(a2[0], a2[1], a2[2]);
  return { L: i2[0], a: i2[1], b: i2[2] };
}, ht = (t2, e2, s2) => {
  const r2 = ((t3, e3, s3) => {
    const r3 = (t4) => t4 > 6 / 29 ? t4 ** 3 : 3 * (6 / 29) ** 2 * (t4 - 4 / 29), a3 = (t3 + 16) / 116, i2 = e3 / 500, n2 = s3 / 200;
    return [rt[0] * r3(a3 + i2), rt[1] * r3(a3), rt[2] * r3(a3 - n2)];
  })(t2, e2, s2), a2 = ot(r2[0], r2[1], r2[2], st).map(nt);
  return { R: V(a2[0] * h, 0, h), G: V(a2[1] * h, 0, h), B: V(a2[2] * h, 0, h) };
}, dt = (t2, e2, s2) => {
  const r2 = Math.sqrt(e2 ** 2 + s2 ** 2), a2 = K(Math.atan2(s2, e2));
  return { L: t2, C: r2, H: Q(a2) };
}, mt = (t2, e2, s2) => {
  const r2 = z(s2);
  return { L: t2, a: e2 * Math.cos(r2), b: e2 * Math.sin(r2) };
}, At = (t2, e2, s2) => {
  const r2 = ut(t2, e2, s2);
  return dt(r2.L, r2.a, r2.b);
}, bt = (t2, e2, s2) => {
  const r2 = mt(t2, e2, s2);
  return ht(r2.L, r2.a, r2.b);
}, pt = (t2, e2, s2, r2 = 1) => ({ H: lt(t2, e2, s2, r2).H, W: U(Math.min(t2, e2, s2) / h * 100), B: U(100 * (1 - Math.max(t2, e2, s2) / h)), A: r2 }), gt = (t2, e2, s2) => {
  const r2 = 1 - (s2 /= 100) - (e2 /= 100), a2 = r2 * (1 - Math.abs(t2 / 60 % 2 - 1));
  let i2 = 0, n2 = 0, o2 = 0;
  return t2 < 60 ? (i2 = r2, n2 = a2, o2 = 0) : t2 >= 60 && t2 < 120 ? (i2 = a2, n2 = r2, o2 = 0) : t2 >= 120 && t2 < 180 ? (i2 = 0, n2 = r2, o2 = a2) : t2 >= 180 && t2 < 240 ? (i2 = 0, n2 = a2, o2 = r2) : t2 >= 240 && t2 < 300 ? (i2 = a2, n2 = 0, o2 = r2) : t2 >= 300 && (i2 = r2, n2 = 0, o2 = a2), i2 += e2, n2 += e2, o2 += e2, { R: V(i2 * h, 0, h), G: V(n2 * h, 0, h), B: V(o2 * h, 0, h) };
}, Ht = (t2, e2, s2, r2) => ({ R: U(h * (1 - t2) * (r2 = 1 - r2)), G: U(h * (1 - e2) * r2), B: U(h * (1 - s2) * r2) }), Ct = (t2, e2, s2) => {
  t2 /= h, e2 /= h, s2 /= h;
  const r2 = 1 - Math.max(t2, e2, s2), a2 = 1 - r2, i2 = a2 && (a2 - e2) / a2, n2 = a2 && (a2 - s2) / a2;
  return { C: U(100 * (a2 && (a2 - t2) / a2)), M: U(100 * i2), Y: U(100 * n2), K: U(100 * r2) };
}, Lt = (t2, e2) => {
  if (t2 < 0 && (t2 += 360), t2 > 360 && (t2 -= 360), 360 === t2 || 0 === t2) return t2;
  const s2 = [[0, 120], [120, 180], [180, 240], [240, 360]], r2 = [[0, 60], [60, 120], [120, 240], [240, 360]], a2 = e2 ? r2 : s2;
  let i2 = 0, n2 = 0, o2 = 0, c2 = 0;
  return (e2 ? s2 : r2).find((e3, s3) => t2 >= e3[0] && t2 < e3[1] && (i2 = e3[0], n2 = e3[1], o2 = a2[s3][0], c2 = a2[s3][1], true)), o2 + (c2 - o2) / (n2 - i2) * (t2 - i2);
};
class Bt {
  get rgb() {
    return this._rgb;
  }
}
class Et extends Bt {
  constructor(t2) {
    var _a, _b, _c, _d;
    super();
    const e2 = t2.match(F.HEX).groups;
    this._r = (_a = e2.r) != null ? _a : e2.rr, this._g = (_b = e2.g) != null ? _b : e2.gg, this._b = (_c = e2.b) != null ? _c : e2.bb, this._a = (_d = e2.a) != null ? _d : e2.aa;
    const s2 = { R: D(this._r), G: D(this._g), B: D(this._b) };
    void 0 !== this._a && (s2.A = D(this._a) / h), this._rgb = s2;
  }
}
class ft {
  constructor(t2, e2, s2) {
    this._operations = /* @__PURE__ */ new Map([[R.DIVISION, this._division], [R.MULTIPLICATION, this._multiplication], [R.SUM, this._sum], [R.REST, this._rest]]), this._colorIndex = t2;
    let r2 = e2, a2 = 0;
    if (Number.isNaN(+e2)) if (e2 in s2) this._result = s2[e2];
    else if (R.REGEXP.test(r2)) R.REGEXP.lastIndex = 0, this._result = this._getCalcValue(r2, s2);
    else {
      for (; R.SCOPED.test(r2) && a2 < 100; ) {
        if (R.SCOPED.lastIndex = 0, r2 = r2.replace(R.SCOPED, (t3, e3) => this._calculate(e3, s2).toString()), R.REGEXP.test(r2)) {
          R.REGEXP.lastIndex = 0;
          break;
        }
        a2++;
      }
      this._result = this._getCalcValue(r2, s2);
    }
    else this._result = +e2;
  }
  _division(t2, e2) {
    return t2 / e2;
  }
  _multiplication(t2, e2) {
    return t2 * e2;
  }
  _sum(t2, e2) {
    return t2 + e2;
  }
  _rest(t2, e2) {
    return t2 - e2;
  }
  _getCalcValue(t2, e2) {
    const s2 = t2.match(R.REGEXP).groups.operation, r2 = this._calculate(s2, e2);
    if (Number.isNaN(r2)) throw new Error(`Invalid value for ${this._colorIndex}. ${s2} is not a valid operation for a relative color`);
    return r2;
  }
  _calculate(t2, e2) {
    return this._operations.forEach((s2, r2) => {
      let a2 = 0;
      for (; r2.test(t2) && a2 < 100; ) t2 = t2.replace(r2, (t3, r3, a3) => {
        var _a, _b;
        return s2((_a = e2[r3]) != null ? _a : +r3, (_b = e2[a3]) != null ? _b : +a3).toString();
      }), a2++;
    }), +t2;
  }
  get result() {
    return this._result;
  }
}
class Ft extends Bt {
  get hasPercentageAlpha() {
    return S.test(this._a);
  }
}
class Rt extends Ft {
  constructor(t2, e2) {
    var _a;
    super();
    const s2 = t2.match(F.RGB).groups, { r_legacy: r2, g_legacy: a2, b_legacy: i2, a_legacy: n2, r: o2, g: c2, b: l2, a: u2, from: d2, relative_r: m2, relative_g: A2, relative_b: b2, relative_a: p2 } = s2;
    if (d2) {
      const t3 = e2(d2), s3 = { r: t3.R, g: t3.G, b: t3.B, alpha: (_a = t3.A) != null ? _a : 1 }, r3 = new ft("r", m2, s3).result, a3 = new ft("g", A2, s3).result, i3 = new ft("b", b2, s3).result, n3 = { R: Math.min(r3, h), G: Math.min(a3, h), B: Math.min(i3, h) };
      if (p2) {
        const t4 = new ft("alpha", p2, s3).result;
        n3.A = Math.min(t4, 1);
      }
      this._rgb = n3;
    } else {
      this._r = r2 != null ? r2 : o2, this._g = a2 != null ? a2 : c2, this._b = i2 != null ? i2 : l2, this._a = n2 != null ? n2 : u2;
      const t3 = { R: Math.min(W(this._r), h), G: Math.min(W(this._g), h), B: Math.min(W(this._b), h) };
      void 0 !== this._a && (t3.A = Z(this._a)), this._rgb = t3;
    }
  }
  get hasPercentageValues() {
    return S.test(this._r) && S.test(this._g) && S.test(this._b);
  }
  static test(t2) {
    return F.RGB.test(t2);
  }
}
class _t extends Ft {
  get angleUnit() {
    if (this._h) {
      const t2 = this._h.match(_).groups.units;
      return "" === t2 ? k.NONE : t2;
    }
    return k.NONE;
  }
}
class St extends _t {
  constructor(t2, e2) {
    super();
    const s2 = t2.match(F.HSL).groups, { h_legacy: r2, s_legacy: a2, l_legacy: i2, a_legacy: n2, h: o2, s: c2, l: l2, a: u2, from: h2, relative_h: m2, relative_s: A2, relative_l: b2, relative_a: p2 } = s2;
    if (h2) {
      const t3 = e2(h2), s3 = lt(t3.R, t3.G, t3.B, t3.A), r3 = { h: s3.H, s: s3.S, l: s3.L, alpha: s3.A }, a3 = new ft("h", m2, r3).result, i3 = new ft("s", A2, r3).result, n3 = new ft("l", b2, r3).result, o3 = ct(V(a3, 0, 360), V(i3, 0, d), V(n3, 0, d));
      if (p2) {
        const t4 = new ft("alpha", p2, r3).result;
        o3.A = V(t4, 0, 1);
      }
      this._rgb = o3;
    } else {
      this._h = r2 != null ? r2 : o2, this._s = a2 != null ? a2 : c2, this._l = i2 != null ? i2 : l2, this._a = n2 != null ? n2 : u2;
      const t3 = ct(Q(this._h), j(this._s), j(this._l));
      void 0 !== this._a && (t3.A = Z(this._a)), this._rgb = t3;
    }
  }
  static test(t2) {
    return F.HSL.test(t2);
  }
}
class yt extends _t {
  constructor(t2, e2) {
    super();
    const s2 = t2.match(F.HWB).groups, { h: r2, w: a2, b: i2, a: n2, from: o2, relative_h: c2, relative_w: l2, relative_b: u2, relative_a: h2 } = s2;
    if (o2) {
      const t3 = e2(o2), s3 = pt(t3.R, t3.G, t3.B, t3.A), r3 = { h: s3.H, w: s3.W, b: s3.B, alpha: s3.A }, a3 = new ft("h", c2, r3).result, i3 = new ft("w", l2, r3).result, n3 = new ft("b", u2, r3).result, m2 = gt(V(a3, 0, 360), V(i3, 0, d), V(n3, 0, d));
      if (h2) {
        const t4 = new ft("alpha", h2, r3).result;
        m2.A = V(t4, 0, 1);
      }
      this._rgb = m2;
    } else {
      this._h = r2, this._w = a2, this._b = i2, this._a = n2;
      const t3 = gt(Q(this._h), j(this._w), j(this._b));
      void 0 !== this._a && (t3.A = Z(this._a)), this._rgb = t3;
    }
  }
  static test(t2) {
    return F.HWB.test(t2);
  }
}
class vt extends Ft {
  constructor(t2, e2) {
    var _a;
    super();
    const s2 = t2.match(F.CIELab).groups, { L: r2, a: a2, b: i2, A: n2, from: o2, relative_L: c2, relative_a: l2, relative_b: u2, relative_A: h2 } = s2;
    if (o2) {
      const t3 = e2(o2), s3 = ut(t3.R, t3.G, t3.B), r3 = { l: s3.L, a: s3.a, b: s3.b, alpha: (_a = t3.A) != null ? _a : 1 }, a3 = new ft("l", c2, r3).result, i3 = new ft("a", l2, r3).result, n3 = new ft("b", u2, r3).result, A2 = ht(V(a3, 0, d), V(i3, -125, m), V(n3, -125, m));
      if (h2) {
        const t4 = new ft("alpha", h2, r3).result;
        A2.A = V(t4, 0, 1);
      }
      this._rgb = A2;
    } else {
      this._L = r2, this._A = a2, this._B = i2, this._a = n2;
      const t3 = ht(j(this._L), N(this._A), N(this._B));
      void 0 !== this._a && (t3.A = Z(this._a)), this._rgb = t3;
    }
  }
  get hasPercentageValues() {
    return S.test(this._L) && S.test(this._A) && S.test(this._B);
  }
  static test(t2) {
    return F.CIELab.test(t2);
  }
}
class Gt extends _t {
  constructor(t2, e2) {
    var _a;
    super();
    const s2 = t2.match(F.LCH).groups, { l: r2, c: a2, h: i2, a: n2, from: o2, relative_l: c2, relative_c: l2, relative_h: u2, relative_a: h2 } = s2;
    if (o2) {
      const t3 = e2(o2), s3 = At(t3.R, t3.G, t3.B), r3 = { l: s3.L, c: s3.C, h: s3.H, alpha: (_a = t3.A) != null ? _a : 1 }, a3 = new ft("l", c2, r3).result, i3 = new ft("c", l2, r3).result, n3 = new ft("h", u2, r3).result, m2 = bt(V(a3, 0, d), V(i3, -150, A), Q(n3));
      if (h2) {
        const t4 = new ft("alpha", h2, r3).result;
        m2.A = V(t4, 0, 1);
      }
      this._rgb = m2;
    } else {
      this._l = r2, this._c = a2, this._h = i2, this._a = n2;
      const t3 = bt(j(this._l), T(this._c), Q(this._h));
      void 0 !== this._a && (t3.A = Z(this._a)), this._rgb = t3;
    }
  }
  get hasPercentageValues() {
    return S.test(this._l) && S.test(this._c);
  }
  static test(t2) {
    return F.LCH.test(t2);
  }
}
class Mt extends Ft {
  constructor(t2) {
    var _a, _b, _c, _d, _e;
    super();
    const e2 = t2.match(F.CMYK).groups;
    this._c = (_a = e2.c_legacy) != null ? _a : e2.c, this._m = (_b = e2.m_legacy) != null ? _b : e2.m, this._y = (_c = e2.y_legacy) != null ? _c : e2.y, this._k = (_d = e2.k_legacy) != null ? _d : e2.k, this._a = (_e = e2.a_legacy) != null ? _e : e2.a;
    const s2 = Ht(X(this._c), X(this._m), X(this._y), X(this._k));
    void 0 !== this._a && (s2.A = Z(this._a)), this._rgb = s2;
  }
  get hasPercentageValues() {
    return S.test(this._c) && S.test(this._m) && S.test(this._y) && S.test(this._k);
  }
  static test(t2) {
    return F.CMYK.test(t2);
  }
}
const kt = (t2) => "string" == typeof t2 ? ((t3) => {
  let e2;
  if (Object.keys(b).some((s2) => {
    if (F[s2].test(t3)) return e2 = s2, true;
  }), !e2 && ~L.indexOf(t3) && (e2 = b.HEX), !e2) throw new Error("The provided string color doesn't have a correct format");
  return e2;
})(t2) : ((t3) => {
  let e2, s2 = false;
  const r2 = Y(Object.keys(t3));
  if (E[r2] && (e2 = E[r2]), e2 && e2 === b.RGB) {
    const r3 = Object.entries(t3).some((t4) => !y.test(`${t4[1]}`)), a2 = Object.entries(t3).some((t4) => !(S.test(`${t4[1]}`) || !y.test(`${t4[1]}`) && !isNaN(+t4[1]) && +t4[1] <= h));
    r3 && a2 && (s2 = true), r3 || (e2 = b.HEX);
  }
  if (!e2 || s2) throw new Error("The provided color object doesn't have the proper keys or format");
  return e2;
})(t2), wt = { [b.HEX](t2) {
  const e2 = ~L.indexOf(t2) ? H[t2] : t2;
  return new Et(e2).rgb;
}, [b.RGB]: (t2) => new Rt(t2, Pt).rgb, [b.HSL]: (t2) => new St(t2, Pt).rgb, [b.HWB]: (t2) => new yt(t2, Pt).rgb, [b.CIELab]: (t2) => new vt(t2, Pt).rgb, [b.LCH]: (t2) => new Gt(t2, Pt).rgb, [b.CMYK]: (t2) => new Mt(t2).rgb }, It = { [b.HEX](t2) {
  const e2 = { R: W(`${t2.R}`), G: W(`${t2.G}`), B: W(`${t2.B}`) };
  return O(t2, "A") && (e2.A = Math.min(W(`${t2.A}`, true), 1)), e2;
}, [b.RGB](t2) {
  return this.HEX(t2);
}, [b.HSL](t2) {
  const e2 = j(`${t2.S}`), s2 = j(`${t2.L}`), r2 = ct(Q(t2.H), e2, s2);
  return O(t2, "A") && (r2.A = Z(t2.A)), r2;
}, [b.HWB](t2) {
  const e2 = j(`${t2.W}`), s2 = j(`${t2.B}`), r2 = gt(Q(t2.H), e2, s2);
  return O(t2, "A") && (r2.A = Z(t2.A)), r2;
}, [b.CIELab](t2) {
  const e2 = j(`${t2.L}`), s2 = N(`${t2.a}`), r2 = N(`${t2.b}`), a2 = ht(e2, s2, r2);
  return O(t2, "A") && (a2.A = Z(t2.A)), a2;
}, [b.LCH](t2) {
  const e2 = j(`${t2.L}`), s2 = T(`${t2.C}`), r2 = Q(`${t2.H}`), a2 = bt(e2, s2, r2);
  return O(t2, "A") && (a2.A = Z(t2.A)), a2;
}, [b.CMYK](t2) {
  const e2 = X(`${t2.C}`), s2 = X(`${t2.M}`), r2 = X(`${t2.Y}`), a2 = X(`${t2.K}`), i2 = Ht(e2, s2, r2, a2);
  return O(t2, "A") && (i2.A = Z(t2.A)), i2;
} }, Pt = (t2, e2 = kt(t2)) => "string" == typeof t2 ? wt[e2](t2) : It[e2](t2), Ot = (t2, ...e2) => {
  const s2 = [], r2 = [], a2 = [], i2 = [], n2 = [], o2 = [], c2 = [], l2 = Object.values(k), u2 = Object.values(w), h2 = Object.values(I), d2 = { legacyCSS: 0, spacesAfterCommas: 0, cmykFunction: 0 };
  for (const m2 of e2) if ("string" == typeof m2) {
    if (s2.push(m2), m2.includes(",")) {
      d2.legacyCSS++;
      const t3 = m2.match(G);
      1 === new Set(t3).size && M.test(t3[0].slice(1)) && d2.spacesAfterCommas++;
    }
    if (St.test(m2)) {
      const t3 = new St(m2, Pt);
      r2.push(t3.angleUnit), c2.push(t3.hasPercentageAlpha);
      continue;
    }
    if (yt.test(m2)) {
      const t3 = new yt(m2, Pt);
      r2.push(t3.angleUnit), c2.push(t3.hasPercentageAlpha);
      continue;
    }
    if (Rt.test(m2)) {
      const t3 = new Rt(m2, Pt);
      a2.push(t3.hasPercentageValues), c2.push(t3.hasPercentageAlpha);
      continue;
    }
    if (vt.test(m2)) {
      const t3 = new vt(m2, Pt);
      i2.push(t3.hasPercentageValues), c2.push(t3.hasPercentageAlpha);
      continue;
    }
    if (Gt.test(m2)) {
      const t3 = new Gt(m2, Pt);
      r2.push(t3.angleUnit), n2.push(t3.hasPercentageValues), c2.push(t3.hasPercentageAlpha);
      continue;
    }
    if (Mt.test(m2)) {
      const t3 = new Mt(m2);
      o2.push(t3.hasPercentageValues), m2.startsWith("cmyk") && d2.cmykFunction++, c2.push(t3.hasPercentageAlpha);
    }
  }
  return { decimals: typeof t2.decimals === f.NUMBER ? t2.decimals : P.decimals, legacyCSS: typeof t2.legacyCSS === f.BOOLEAN ? t2.legacyCSS : Boolean(s2.length && d2.legacyCSS === s2.length) || P.legacyCSS, spacesAfterCommas: typeof t2.spacesAfterCommas === f.BOOLEAN ? t2.spacesAfterCommas : Boolean(s2.length && d2.spacesAfterCommas === s2.length) || P.spacesAfterCommas, anglesUnit: t2.anglesUnit && l2.includes(t2.anglesUnit) ? t2.anglesUnit : 1 === new Set(r2).size ? r2[0] : P.anglesUnit, rgbUnit: t2.rgbUnit && u2.includes(t2.rgbUnit) ? t2.rgbUnit : 1 === new Set(a2).size && a2[0] ? w.PERCENT : P.rgbUnit, labUnit: t2.labUnit && u2.includes(t2.labUnit) ? t2.labUnit : 1 === new Set(i2).size && i2[0] ? w.PERCENT : P.labUnit, lchUnit: t2.lchUnit && u2.includes(t2.lchUnit) ? t2.lchUnit : 1 === new Set(n2).size && n2[0] ? w.PERCENT : P.lchUnit, cmykUnit: t2.cmykUnit && u2.includes(t2.cmykUnit) ? t2.cmykUnit : 1 !== new Set(o2).size || o2[0] ? P.cmykUnit : w.NONE, alphaUnit: t2.alphaUnit && u2.includes(t2.alphaUnit) ? t2.alphaUnit : 1 === new Set(c2).size && c2[0] ? w.PERCENT : P.alphaUnit, cmykFunction: t2.cmykFunction && h2.includes(t2.cmykFunction) ? t2.cmykFunction : o2.length && o2.length === d2.cmykFunction ? I.CMYK : P.cmykFunction };
}, xt = (t2, e2) => ({ H: U(t2.H, e2), S: U(t2.S, e2), L: U(t2.L, e2) }), jt = (t2) => t2 ? ", " : ",", Dt = (t2, e2) => {
  const s2 = Y(Object.keys(t2));
  return B[E[s2]].reduce((s3, r2, a2) => {
    const i2 = t2[r2];
    return void 0 !== i2 && s3.push(e2(i2, a2)), s3;
  }, []);
}, $t = (t2, e2) => t2.replace(v, (t3, s2) => `${e2[+s2 - 1]}`), Wt = (t2, e2, s2 = false) => {
  const { alphaUnit: r2, legacyCSS: a2, decimals: i2 } = e2;
  return r2 !== w.PERCENT || a2 && !s2 ? U(t2, i2) : `${U(100 * t2, i2)}%`;
}, Nt = (t2) => {
  const { anglesUnit: e2, decimals: s2 } = t2;
  return (r2, a2) => 0 === a2 && e2 !== k.NONE ? `${U(J(r2, e2), s2)}${e2}` : 3 === a2 ? Wt(r2, t2) : U(r2, s2);
}, Tt = { [b.HEX]: (t2) => {
  const e2 = Dt(t2, (t3) => ((t4) => {
    let e3 = U(t4, 0).toString(16).toUpperCase();
    return 1 === e3.length && (e3 = `0${e3}`), e3;
  })(U(t3))), s2 = 4 === e2.length ? "#{1}{2}{3}{4}" : "#{1}{2}{3}";
  return $t(s2, e2);
}, [b.RGB]: (t2, e2) => {
  const { decimals: s2, legacyCSS: r2, spacesAfterCommas: a2, rgbUnit: i2 } = e2, n2 = jt(a2), o2 = Dt(t2, (t3, r3) => {
    return i2 === w.PERCENT && r3 < 3 ? `${a3 = t3, n3 = s2, U(a3 / h * 100, n3)}%` : 3 === r3 ? Wt(t3, e2) : U(t3, s2);
    var a3, n3;
  }), c2 = r2 ? 4 === o2.length ? `rgba({1}${n2}{2}${n2}{3}${n2}{4})` : `rgb({1}${n2}{2}${n2}{3})` : 4 === o2.length ? "rgb({1} {2} {3} / {4})" : "rgb({1} {2} {3})";
  return $t(c2, o2);
}, [b.HSL]: (t2, e2) => {
  const { legacyCSS: s2, spacesAfterCommas: r2 } = e2, a2 = jt(r2), i2 = Nt(e2), n2 = Dt(t2, i2), o2 = s2 ? 4 === n2.length ? `hsla({1}${a2}{2}%${a2}{3}%${a2}{4})` : `hsl({1}${a2}{2}%${a2}{3}%)` : 4 === n2.length ? "hsl({1} {2}% {3}% / {4})" : "hsl({1} {2}% {3}%)";
  return $t(o2, n2);
}, [b.HWB]: (t2, e2) => {
  const s2 = Nt(e2), r2 = Dt(t2, s2), a2 = 4 === r2.length ? "hwb({1} {2}% {3}% / {4})" : "hwb({1} {2}% {3}%)";
  return $t(a2, r2);
}, [b.CIELab]: (t2, e2) => {
  const { decimals: s2, labUnit: r2 } = e2, a2 = Dt(t2, (t3, a3) => {
    if (0 === a3) {
      const e3 = U(j(t3), s2);
      return r2 === w.PERCENT ? `${e3}%` : `${e3}`;
    }
    return a3 < 3 ? r2 === w.PERCENT ? `${i3 = t3, n2 = s2, U(i3 / m * 100, n2)}%` : U(t3, s2) : Wt(t3, e2, true);
    var i3, n2;
  }), i2 = 4 === a2.length ? "lab({1} {2} {3} / {4})" : "lab({1} {2} {3})";
  return $t(i2, a2);
}, [b.LCH]: (t2, e2) => {
  const { decimals: s2, lchUnit: r2, anglesUnit: a2 } = e2, i2 = Dt(t2, (t3, i3) => {
    if (0 === i3) {
      const e3 = U(j(t3), s2);
      return r2 === w.PERCENT ? `${e3}%` : `${e3}`;
    }
    return 1 === i3 ? r2 === w.PERCENT ? `${n3 = t3, o2 = s2, U(n3 / A * 100, o2)}%` : U(t3, s2) : 2 === i3 ? a2 !== k.NONE ? `${U(J(t3, a2), s2)}${a2}` : U(t3, s2) : Wt(t3, e2, true);
    var n3, o2;
  }), n2 = 4 === i2.length ? "lch({1} {2} {3} / {4})" : "lch({1} {2} {3})";
  return $t(n2, i2);
}, [b.CMYK]: (t2, e2) => {
  const { decimals: s2, legacyCSS: r2, spacesAfterCommas: a2, cmykUnit: i2, cmykFunction: n2 } = e2, o2 = jt(a2), c2 = Dt(t2, (t3, r3) => i2 === w.PERCENT && r3 < 4 ? `${U(t3, s2)}%` : 4 === r3 ? Wt(t3, e2) : U(t3 / 100, s2)), l2 = r2 ? 5 === c2.length ? `${n2}({1}${o2}{2}${o2}{3}${o2}{4}${o2}{5})` : `${n2}({1}${o2}{2}${o2}{3}${o2}{4})` : 5 === c2.length ? `${n2}({1} {2} {3} {4} / {5})` : `${n2}({1} {2} {3} {4})`;
  return $t(l2, c2);
} }, Xt = (t2, e2, s2) => e2.reduce((e3, r2) => [...e3, { ...t2, H: s2 === g.ADDITIVE ? Q(t2.H + r2) : Q(Lt(Lt(t2.H, false) + r2, true)) }], [{ ...t2 }]), Yt = (t2, e2) => Xt(t2, [30, -30], e2), Ut = (t2, e2) => Xt(t2, [180], e2), Vt = (t2, e2) => Xt(t2, [150, -150], e2), Kt = (t2, e2) => Xt(t2, [120, -120], e2), zt = (t2, e2) => Xt(t2, [60, -120, 180], e2), qt = (t2, e2) => Xt(t2, [90, -90, 180], e2), Qt = { [b.HEX]: (t2) => ({ R: $(t2.R), G: $(t2.G), B: $(t2.B) }), HEXA(t2) {
  const e2 = Qt.HEX(t2);
  return e2.A = O(t2, "A") ? $(t2.A * h) : "0xFF", e2;
}, [b.RGB](t2, e2) {
  const s2 = ee(t2, e2);
  return O(s2, "A") && delete s2.A, s2;
}, RGBA(t2, e2) {
  const s2 = Qt.RGB(t2, e2);
  return s2.A = O(t2, "A") ? U(t2.A) : 1, s2;
}, [b.HSL](t2, e2) {
  const s2 = lt(t2.R, t2.G, t2.B);
  return delete s2.A, xt(s2, e2);
}, HSLA(t2, e2) {
  const s2 = Qt.HSL(t2, e2);
  return s2.A = O(t2, "A") ? U(t2.A, e2) : 1, s2;
}, [b.HWB](t2, e2) {
  const s2 = pt(t2.R, t2.G, t2.B);
  return delete s2.A, a2 = e2, { H: U((r2 = s2).H, a2), W: U(r2.W, a2), B: U(r2.B, a2) };
  var r2, a2;
}, HWBA(t2, e2) {
  const s2 = Qt.HWB(t2, e2);
  return s2.A = O(t2, "A") ? U(t2.A, e2) : 1, s2;
}, [b.CIELab]: (t2, e2) => {
  return s2 = ut(t2.R, t2.G, t2.B), r2 = e2, { L: U(s2.L, r2), a: U(s2.a, r2), b: U(s2.b, r2) };
  var s2, r2;
}, CIELabA(t2, e2) {
  const s2 = Qt.CIELab(t2, e2);
  return s2.A = O(t2, "A") ? U(t2.A, e2) : 1, s2;
}, [b.LCH]: (t2, e2) => {
  return s2 = At(t2.R, t2.G, t2.B), r2 = e2, { L: U(s2.L, r2), C: U(s2.C, r2), H: U(s2.H, r2) };
  var s2, r2;
}, LCHA(t2, e2) {
  const s2 = Qt.LCH(t2, e2);
  return s2.A = O(t2, "A") ? U(t2.A, e2) : 1, s2;
}, [b.CMYK]: (t2, e2) => {
  return s2 = Ct(t2.R, t2.G, t2.B), r2 = e2, { C: U(s2.C, r2), M: U(s2.M, r2), Y: U(s2.Y, r2), K: U(s2.K, r2) };
  var s2, r2;
}, CMYKA(t2, e2) {
  const s2 = Qt.CMYK(t2, e2);
  return s2.A = O(t2, "A") ? U(t2.A, e2) : 1, s2;
} }, Zt = (t2, e2, s2, r2) => {
  const a2 = kt(t2), i2 = "string" == typeof t2, n2 = Pt(t2, a2), o2 = "string" == typeof t2 && O(n2, "A") || "string" != typeof t2 && O(t2, "A"), c2 = lt(n2.R, n2.G, n2.B, n2.A);
  o2 || delete c2.A;
  const l2 = s2 ? c2.L / (e2 + 1) : (100 - c2.L) / (e2 + 1), u2 = Array(e2).fill(null).map((t3, e3) => ({ ...c2, L: c2.L + l2 * (e3 + 1) * (1 - 2 * +s2) }));
  switch (a2) {
    case b.HEX:
    default:
      return u2.map((t3) => {
        const e3 = ct(t3.H, t3.S, t3.L);
        return o2 && (e3.A = t3.A), i2 ? o2 ? Tt.HEX({ ...e3, A: U(e3.A * h) }) : Tt.HEX(e3) : o2 ? Qt.HEXA(e3) : Qt.HEX(e3);
      });
    case b.RGB:
      return u2.map((t3) => {
        const e3 = ct(t3.H, t3.S, t3.L);
        return o2 && (e3.A = t3.A), i2 ? Tt.RGB(e3, r2) : o2 ? Qt.RGBA(e3, r2.decimals) : Qt.RGB(e3, r2.decimals);
      });
    case b.HSL:
      return u2.map((t3) => i2 ? Tt.HSL(t3, r2) : o2 ? Qt.HSLA({ ...ct(t3.H, t3.S, t3.L), A: t3.A }, r2.decimals) : Qt.HSL(ct(t3.H, t3.S, t3.L), r2.decimals));
    case b.HWB:
      return u2.map((t3) => {
        const e3 = ct(t3.H, t3.S, t3.L);
        o2 && (e3.A = t3.A);
        const s3 = o2 ? Qt.HWBA(e3, r2.decimals) : Qt.HWB(e3, r2.decimals);
        return i2 ? Tt.HWB(s3, r2) : s3;
      });
    case b.CIELab:
      return u2.map((t3) => {
        const e3 = ct(t3.H, t3.S, t3.L);
        o2 && (e3.A = t3.A);
        const s3 = o2 ? Qt.CIELabA(e3, r2.decimals) : Qt.CIELab(e3, r2.decimals);
        return i2 ? Tt.CIELab(s3, r2) : s3;
      });
    case b.LCH:
      return u2.map((t3) => {
        const e3 = ct(t3.H, t3.S, t3.L), s3 = At(e3.R, e3.G, e3.B);
        return o2 && (s3.A = t3.A), i2 ? Tt.LCH(s3, r2) : o2 ? Qt.LCHA({ ...e3, A: t3.A }, r2.decimals) : Qt.LCH(e3, r2.decimals);
      });
  }
}, Jt = { buildHarmony(t2, e2, s2, r2) {
  const a2 = kt(t2), i2 = Pt(t2, a2), n2 = lt(i2.R, i2.G, i2.B, i2.A), o2 = "string" == typeof t2 && O(i2, "A") || "string" != typeof t2 && O(t2, "A"), c2 = "string" == typeof t2;
  switch (a2) {
    case b.HEX:
    default:
      return o2 ? this.HEXA(xt(n2, 0), e2, s2, c2) : this.HEX(xt(n2, 0), e2, s2, c2);
    case b.HSL:
      return o2 ? this.HSLA(n2, e2, s2, c2, r2) : this.HSL(n2, e2, s2, c2, r2);
    case b.HWB:
      return o2 ? this.HWBA(n2, e2, s2, c2, r2) : this.HWB(n2, e2, s2, c2, r2);
    case b.RGB:
      return o2 ? this.RGBA(n2, e2, s2, c2, r2) : this.RGB(n2, e2, s2, c2, r2);
    case b.CIELab:
      return o2 ? this.CIELabA(n2, e2, s2, c2, r2) : this.CIELab(n2, e2, s2, c2, r2);
    case b.LCH:
      return o2 ? this.LCHA(n2, e2, s2, c2, r2) : this.LCH(n2, e2, s2, c2, r2);
  }
}, [b.HEX]: (t2, e2, s2, r2) => e2(t2, s2).map((t3) => r2 ? Tt.HEX(ct(t3.H, t3.S, t3.L)) : Qt.HEX(ct(t3.H, t3.S, t3.L))), HEXA: (t2, e2, s2, r2) => e2(t2, s2).map((t3) => r2 ? Tt.HEX({ ...ct(t3.H, t3.S, t3.L), A: Z(t3.A) * h }) : Qt.HEXA({ ...ct(t3.H, t3.S, t3.L), A: Z(t3.A) })), [b.RGB]: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => r2 ? Tt.RGB(ct(t3.H, t3.S, t3.L), a2) : Qt.RGB(ct(t3.H, t3.S, t3.L), a2.decimals)), RGBA: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => r2 ? Tt.RGB({ ...ct(t3.H, t3.S, t3.L), A: Z(t3.A) }, a2) : Qt.RGBA({ ...ct(t3.H, t3.S, t3.L), A: Z(t3.A) }, a2.decimals)), [b.HSL]: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => r2 ? Tt.HSL({ H: t3.H, S: t3.S, L: t3.L }, a2) : Qt.HSL(ct(t3.H, t3.S, t3.L), a2.decimals)), HSLA: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => r2 ? Tt.HSL({ ...t3, A: Z(t3.A) }, a2) : Qt.HSLA({ ...ct(t3.H, t3.S, t3.L), A: Z(t3.A) }, a2.decimals)), [b.HWB]: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => {
  const e3 = ct(t3.H, t3.S, t3.L), s3 = pt(e3.R, e3.G, e3.B);
  return r2 ? Tt.HWB({ H: s3.H, W: s3.W, B: s3.B }, a2) : Qt.HWB(e3, a2.decimals);
}), HWBA: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => {
  const e3 = ct(t3.H, t3.S, t3.L), s3 = pt(e3.R, e3.G, e3.B);
  return r2 ? Tt.HWB({ ...s3, A: Z(t3.A) }, a2) : Qt.HWBA({ ...e3, A: Z(t3.A) }, a2.decimals);
}), [b.CIELab]: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => {
  const e3 = ct(t3.H, t3.S, t3.L);
  return r2 ? Tt.CIELab(ut(e3.R, e3.G, e3.B), a2) : Qt.CIELab(e3, a2.decimals);
}), CIELabA: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => {
  const e3 = ct(t3.H, t3.S, t3.L);
  return r2 ? Tt.CIELab({ ...ut(e3.R, e3.G, e3.B), A: Z(t3.A) }, a2) : Qt.CIELabA({ ...e3, A: Z(t3.A) }, a2.decimals);
}), [b.LCH]: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => {
  const e3 = ct(t3.H, t3.S, t3.L);
  return r2 ? Tt.LCH(At(e3.R, e3.G, e3.B), a2) : Qt.LCH(e3, a2.decimals);
}), LCHA: (t2, e2, s2, r2, a2) => e2(t2, s2).map((t3) => {
  const e3 = ct(t3.H, t3.S, t3.L);
  return r2 ? Tt.LCH({ ...At(e3.R, e3.G, e3.B), A: Z(t3.A) }, a2) : Qt.LCHA({ ...e3, A: Z(t3.A) }, a2.decimals);
}) }, te = { mix(t2, e2) {
  const s2 = t2.map((t3) => {
    const e3 = kt(t3);
    return Pt(t3, e3);
  }), r2 = e2 === g.SUBTRACTIVE ? s2.map((t3) => {
    const e3 = ((t4, e4, s3) => {
      const r3 = Math.min(t4, e4, s3), a3 = Math.min(h - t4, h - e4, h - s3), i3 = t4 - r3, n2 = e4 - r3, o2 = s3 - r3, c2 = Math.min(i3, n2), l2 = i3 - c2, u2 = (n2 + c2) / 2, d2 = (o2 + n2 - c2) / 2, m2 = Math.max(l2, u2, d2) / Math.max(i3, n2, o2), A2 = isNaN(m2) || m2 === 1 / 0 || m2 <= 0 ? 1 : m2;
      return { R: l2 / A2 + a3, Y: u2 / A2 + a3, B: d2 / A2 + a3 };
    })(t3.R, t3.G, t3.B);
    return O(t3, "A") && (e3.A = t3.A), e3;
  }) : null;
  function a2(t3) {
    const s3 = e2 === g.ADDITIVE ? { R: 0, G: 0, B: 0, A: 0 } : { R: 0, Y: 0, B: 0, A: 0 };
    return t3.reduce((t4, s4) => {
      const r3 = O(s4, "A") ? s4.A : 1, a3 = { R: Math.min(t4.R + s4.R * r3, h), B: Math.min(t4.B + s4.B * r3, h), A: 1 - (1 - r3) * (1 - t4.A) }, i3 = "G" in t4 ? t4.G : t4.Y, n2 = "G" in s4 ? s4.G : s4.Y;
      return { ...a3, ...e2 === g.ADDITIVE ? { G: Math.min(i3 + n2 * r3, h) } : { Y: Math.min(i3 + n2 * r3, h) } };
    }, s3);
  }
  let i2;
  if (e2 === g.ADDITIVE) i2 = a2(s2);
  else {
    const t3 = a2(r2);
    i2 = ((t4, e3, s3) => {
      const r3 = Math.min(t4, e3, s3), a3 = Math.min(h - t4, h - e3, h - s3), i3 = t4 - r3, n2 = e3 - r3, o2 = s3 - r3, c2 = Math.min(n2, o2), l2 = i3 + n2 - c2, u2 = n2 + c2, d2 = 2 * (o2 - c2), m2 = Math.max(l2, u2, d2) / Math.max(i3, n2, o2), A2 = isNaN(m2) || m2 === 1 / 0 || m2 <= 0 ? 1 : m2;
      return { R: l2 / A2 + a3, G: u2 / A2 + a3, B: d2 / A2 + a3 };
    })(t3.R, t3.Y, t3.B), i2.A = t3.A;
  }
  return { R: U(i2.R), G: U(i2.G), B: U(i2.B), A: V(i2.A, 0, 1) };
}, [b.HEX](t2, e2, s2) {
  const r2 = this.mix(t2, e2);
  return delete r2.A, s2 ? Tt.HEX(r2) : Qt.HEX(r2);
}, HEXA(t2, e2, s2) {
  const r2 = this.mix(t2, e2);
  return r2.A = s2 ? Z(r2.A) * h : Z(r2.A), s2 ? Tt.HEX(r2) : Qt.HEXA(r2);
}, [b.RGB](t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2);
  return delete a2.A, s2 ? Tt.RGB(a2, r2) : Qt.RGB(a2, r2.decimals);
}, RGBA(t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2);
  return s2 ? Tt.RGB(a2, r2) : Qt.RGBA(a2, r2.decimals);
}, [b.HSL](t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2), i2 = lt(a2.R, a2.G, a2.B);
  return delete a2.A, delete i2.A, s2 ? Tt.HSL(i2, r2) : Qt.HSL(a2, r2.decimals);
}, HSLA(t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2), i2 = lt(a2.R, a2.G, a2.B, a2.A);
  return s2 ? Tt.HSL(i2, r2) : Qt.HSLA(a2, r2.decimals);
}, [b.HWB](t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2), i2 = pt(a2.R, a2.G, a2.B);
  return delete a2.A, delete i2.A, s2 ? Tt.HWB(i2, r2) : Qt.HWB(a2, r2.decimals);
}, HWBA(t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2), i2 = pt(a2.R, a2.G, a2.B, a2.A);
  return s2 ? Tt.HWB(i2, r2) : Qt.HWBA(a2, r2.decimals);
}, [b.CIELab](t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2), i2 = ut(a2.R, a2.G, a2.B);
  return delete a2.A, s2 ? Tt.CIELab(i2, r2) : Qt.CIELab(a2, r2.decimals);
}, CIELabA(t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2), i2 = ut(a2.R, a2.G, a2.B);
  return O(a2, "A") && (i2.A = a2.A), s2 ? Tt.CIELab(i2, r2) : Qt.CIELabA(a2, r2.decimals);
}, [b.LCH](t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2), i2 = At(a2.R, a2.G, a2.B);
  return delete a2.A, s2 ? Tt.LCH(i2, r2) : Qt.LCH(a2, r2.decimals);
}, LCHA(t2, e2, s2, r2) {
  const a2 = this.mix(t2, e2), i2 = At(a2.R, a2.G, a2.B);
  return O(a2, "A") && (i2.A = a2.A), s2 ? Tt.LCH(i2, r2) : Qt.LCHA(a2, r2.decimals);
} }, ee = (t2, e2) => ({ R: U(t2.R, e2), G: U(t2.G, e2), B: U(t2.B, e2), ...O(t2, "A") ? { A: U(t2.A, e2) } : {} }), se = (t2, e2, s2, r2) => r2(Pt(t2, e2), s2), re = (t2, e2, s2, r2, a2) => {
  s2 < 1 && (s2 = 5);
  return ((t3, e3, s3) => {
    const r3 = s3 - 1, a3 = (e3.R - t3.R) / r3, i2 = (e3.G - t3.G) / r3, n2 = (e3.B - t3.B) / r3, o2 = Z(t3.A), c2 = (Z(e3.A) - o2) / r3;
    return Array(s3).fill(null).map((s4, l2) => 0 === l2 ? t3 : l2 === r3 ? e3 : { R: U(t3.R + a3 * l2), G: U(t3.G + i2 * l2), B: U(t3.B + n2 * l2), A: U(o2 + c2 * l2) });
  })(Pt(t2), Pt(e2), s2).map((t3) => a2(t3, r2));
};
function ae(t2) {
  const { from: e2, to: s2, thirdParameter: r2, fourthParameter: a2, translateFunction: i2, cssFunction: n2 } = t2, o2 = "number" == typeof r2 ? re(e2, s2, r2, null == a2 ? void 0 : a2.decimals, i2) : re(e2, s2, 5, null == r2 ? void 0 : r2.decimals, i2);
  return n2 ? o2.map((t3) => {
    var _a;
    return n2(t3, Ot((_a = "number" == typeof r2 ? a2 : r2) != null ? _a : {}, e2, s2));
  }) : o2;
}
function ie(t2) {
  var _a;
  const { colors: e2, secondParameter: s2, thirdParameter: r2, colorMixerFunction: a2, css: i2 } = t2, n2 = Ot((_a = "string" == typeof s2 ? r2 : s2) != null ? _a : {}, ...e2);
  return a2(e2, "string" == typeof s2 ? s2 : g.ADDITIVE, i2, n2);
}
const ne = (t2, e2, s2, r2) => ({ [p.ANALOGOUS]: Jt.buildHarmony(e2, Yt, s2, r2), [p.COMPLEMENTARY]: Jt.buildHarmony(e2, Ut, s2, r2), [p.SPLIT_COMPLEMENTARY]: Jt.buildHarmony(e2, Vt, s2, r2), [p.TRIADIC]: Jt.buildHarmony(e2, Kt, s2, r2), [p.TETRADIC]: Jt.buildHarmony(e2, zt, s2, r2), [p.SQUARE]: Jt.buildHarmony(e2, qt, s2, r2) })[t2], oe = Object.fromEntries(Object.entries(te).map((t2) => {
  const [e2, s2] = t2;
  return [e2, s2.bind(te)];
}));
class ce {
  constructor(t2, e2 = {}) {
    this._options = Ot(e2, t2), this.rgb = Pt(t2), this.update("rgb");
  }
  update(...t2) {
    t2.includes("rgb") || this.updateRGB(), t2.includes("hsl") || this.updateHSL(), t2.includes("hwb") || this.updateHWB(), t2.includes("lab") || this.updateLAB(), t2.includes("lch") || this.updateLCH(), t2.includes("cmyk") || this.updateCMYK();
  }
  updateRGB() {
    this.rgb = { ...ct(this.hsl.H, this.hsl.S, this.hsl.L), A: this.hsl.A };
  }
  updateHSL() {
    this.hsl = lt(this.rgb.R, this.rgb.G, this.rgb.B, this.rgb.A);
  }
  updateHWB() {
    this.hwb = pt(this.rgb.R, this.rgb.G, this.rgb.B, this.rgb.A);
  }
  updateLAB() {
    this.lab = { ...ut(this.rgb.R, this.rgb.G, this.rgb.B), A: this.rgb.A };
  }
  updateLCH() {
    this.lch = { ...At(this.rgb.R, this.rgb.G, this.rgb.B), A: this.rgb.A };
  }
  updateCMYK() {
    this.cmyk = Ct(this.rgb.R, this.rgb.G, this.rgb.B);
  }
  updateRGBFromHWB() {
    this.rgb = { ...gt(this.hwb.H, this.hwb.W, this.hwb.B), A: this.rgb.A };
  }
  updateRGBFromLCH() {
    this.rgb = { ...bt(this.lch.L, this.lch.C, this.lch.H), A: this.rgb.A };
  }
  updateRGBFromCMYK() {
    this.rgb = { ...Ht(this.cmyk.C, this.cmyk.M, this.cmyk.Y, this.cmyk.K), A: this.rgb.A };
  }
  updateRGBFromLAB() {
    this.rgb = { ...ht(this.lab.L, this.lab.a, this.lab.b), A: this.rgb.A };
  }
  updateLCHFromLAB() {
    this.lch = { ...dt(this.lab.L, this.lab.a, this.lab.b), A: this.lab.A };
  }
  updateLABromLCH() {
    this.lab = { ...mt(this.lch.L, this.lch.C, this.lch.H), A: this.lch.A };
  }
  setOptions(t2 = {}) {
    return this._options = { ...this._options, ...t2 }, this;
  }
  setR(t2) {
    this.rgb.R = V(t2, 0, h), this.update("rgb");
  }
  setG(t2) {
    return this.rgb.G = V(t2, 0, h), this.update("rgb"), this;
  }
  setB(t2) {
    return this.rgb.B = V(t2, 0, h), this.update("rgb"), this;
  }
  setH(t2) {
    return this.hsl.H = Q(t2), this.update("hsl"), this;
  }
  setS(t2) {
    return this.hsl.S = V(t2, 0, d), this.update("hsl"), this;
  }
  setL(t2) {
    return this.hsl.L = V(t2, 0, d), this.update("hsl"), this;
  }
  setWhiteness(t2) {
    return this.hwb.W = V(t2, 0, d), this.updateRGBFromHWB(), this.update("rgb", "hwb"), this;
  }
  setBlackness(t2) {
    return this.hwb.B = V(t2, 0, d), this.updateRGBFromHWB(), this.update("rgb", "hwb"), this;
  }
  setCIEL(t2) {
    return this.lab.L = V(t2, 0, d), this.updateRGBFromLAB(), this.updateLCHFromLAB(), this.update("rgb", "lab", "lch"), this;
  }
  setCIEa(t2) {
    return this.lab.a = V(t2, -125, m), this.updateRGBFromLAB(), this.updateLCHFromLAB(), this.update("rgb", "lab", "lch"), this;
  }
  setCIEb(t2) {
    return this.lab.b = V(t2, -125, m), this.updateRGBFromLAB(), this.updateLCHFromLAB(), this.update("rgb", "lab", "lch"), this;
  }
  setLCHL(t2) {
    return this.lch.L = V(t2, 0, d), this.updateRGBFromLCH(), this.updateLABromLCH(), this.update("rgb", "lab", "lch"), this;
  }
  setLCHC(t2) {
    return this.lch.C = V(t2, 0, A), this.updateRGBFromLCH(), this.updateLABromLCH(), this.update("rgb", "lab", "lch"), this;
  }
  setLCHH(t2) {
    return this.lch.H = Q(t2), this.updateRGBFromLCH(), this.updateLABromLCH(), this.update("rgb", "lab", "lch"), this;
  }
  setA(t2) {
    const e2 = V(t2, 0, 1);
    return this.rgb.A = e2, this.hsl.A = e2, this.hwb.A = e2, this.lab.A = e2, this.lch.A = e2, this.cmyk.A = e2, this;
  }
  setC(t2) {
    return this.cmyk.C = V(t2, 0, 100), this.updateRGBFromCMYK(), this.update("cmyk"), this;
  }
  setM(t2) {
    return this.cmyk.M = V(t2, 0, 100), this.updateRGBFromCMYK(), this.update("cmyk"), this;
  }
  setY(t2) {
    return this.cmyk.Y = V(t2, 0, 100), this.updateRGBFromCMYK(), this.update("cmyk"), this;
  }
  setK(t2) {
    return this.cmyk.K = V(t2, 0, 100), this.updateRGBFromCMYK(), this.update("cmyk"), this;
  }
  get options() {
    return this._options;
  }
  get R() {
    return U(this.rgb.R, this.options.decimals);
  }
  get G() {
    return U(this.rgb.G, this.options.decimals);
  }
  get B() {
    return U(this.rgb.B, this.options.decimals);
  }
  get H() {
    return U(this.hsl.H, this.options.decimals);
  }
  get S() {
    return U(this.hsl.S, this.options.decimals);
  }
  get L() {
    return U(this.hsl.L, this.options.decimals);
  }
  get Whiteness() {
    return U(this.hwb.W, this.options.decimals);
  }
  get Blackness() {
    return U(this.hwb.B, this.options.decimals);
  }
  get CIEL() {
    return U(this.lab.L, this.options.decimals);
  }
  get CIEa() {
    return U(this.lab.a, this.options.decimals);
  }
  get CIEb() {
    return U(this.lab.b, this.options.decimals);
  }
  get LCHL() {
    return U(this.lch.L, this.options.decimals);
  }
  get LCHC() {
    return U(this.lch.C, this.options.decimals);
  }
  get LCHH() {
    return U(this.lch.H, this.options.decimals);
  }
  get A() {
    return U(this.hsl.A, this.options.decimals);
  }
  get C() {
    return U(this.cmyk.C, this.options.decimals);
  }
  get M() {
    return U(this.cmyk.M, this.options.decimals);
  }
  get Y() {
    return U(this.cmyk.Y, this.options.decimals);
  }
  get K() {
    return U(this.cmyk.K, this.options.decimals);
  }
  get HEXObject() {
    return Qt.HEX(this.rgb);
  }
  get HEXAObject() {
    return Qt.HEXA(this.rgb);
  }
  get RGBObject() {
    return { R: this.R, G: this.G, B: this.B };
  }
  get RGBAObject() {
    return { ...this.RGBObject, A: this.A };
  }
  get HSLObject() {
    return { H: this.H, S: this.S, L: this.L };
  }
  get HSLAObject() {
    return { ...this.HSLObject, A: this.A };
  }
  get HWBObject() {
    return { H: this.H, W: this.Whiteness, B: this.Blackness };
  }
  get HWBAObject() {
    return { ...this.HWBObject, A: this.A };
  }
  get CIELabObject() {
    return { L: this.CIEL, a: this.CIEa, b: this.CIEb };
  }
  get CIELabAObject() {
    return { ...this.CIELabObject, A: this.A };
  }
  get LCHObject() {
    return { L: this.LCHL, C: this.LCHC, H: this.LCHH };
  }
  get LCHAObject() {
    return { ...this.LCHObject, A: this.A };
  }
  get CMYKObject() {
    return { C: this.C, M: this.M, Y: this.Y, K: this.K };
  }
  get CMYKAObject() {
    return { ...this.CMYKObject, A: this.A };
  }
  get HEX() {
    return Tt.HEX({ R: this.R, G: this.G, B: this.B });
  }
  get HEXA() {
    return Tt.HEX({ R: this.R, G: this.G, B: this.B, A: this.A * h });
  }
  get RGB() {
    return Tt.RGB({ R: this.R, G: this.G, B: this.B }, this.options);
  }
  get RGBA() {
    return Tt.RGB({ R: this.R, G: this.G, B: this.B, A: this.A }, this.options);
  }
  get HSL() {
    return Tt.HSL({ H: this.H, S: this.S, L: this.L }, this.options);
  }
  get HSLA() {
    return Tt.HSL({ H: this.H, S: this.S, L: this.L, A: this.A }, this.options);
  }
  get HWB() {
    return Tt.HWB({ H: this.H, W: this.Whiteness, B: this.Blackness }, this.options);
  }
  get HWBA() {
    return Tt.HWB({ H: this.H, W: this.Whiteness, B: this.Blackness, A: this.A }, this.options);
  }
  get CIELab() {
    return Tt.CIELab({ L: this.CIEL, a: this.CIEa, b: this.CIEb }, this.options);
  }
  get CIELabA() {
    return Tt.CIELab({ L: this.CIEL, a: this.CIEa, b: this.CIEb, A: this.A }, this.options);
  }
  get LCH() {
    return Tt.LCH({ L: this.LCHL, C: this.LCHC, H: this.LCHH }, this.options);
  }
  get LCHA() {
    return Tt.LCH({ L: this.LCHL, C: this.LCHC, H: this.LCHH, A: this.A }, this.options);
  }
  get CMYK() {
    return Tt.CMYK({ C: this.C, M: this.M, Y: this.Y, K: this.K }, this.options);
  }
  get CMYKA() {
    return Tt.CMYK({ C: this.C, M: this.M, Y: this.Y, K: this.K, A: this.A }, this.options);
  }
  static toHEXObject(t2) {
    const e2 = kt(t2);
    return se(t2, e2, 0, Qt.HEX);
  }
  static toHEX(t2) {
    return Tt.HEX(ce.toHEXObject(t2));
  }
  static toHEXAObject(t2) {
    const e2 = kt(t2);
    return se(t2, e2, 0, Qt.HEXA);
  }
  static toHEXA(t2) {
    return Tt.HEX(ce.toHEXAObject(t2));
  }
  static toRGBObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.RGB);
  }
  static toRGB(t2, e2 = {}) {
    const s2 = ce.toRGBObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.RGB(s2, r2);
  }
  static toRGBAObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.RGBA);
  }
  static toRGBA(t2, e2 = {}) {
    const s2 = ce.toRGBAObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.RGB(s2, r2);
  }
  static toHSLObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.HSL);
  }
  static toHSL(t2, e2 = {}) {
    const s2 = ce.toHSLObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.HSL(s2, r2);
  }
  static toHSLAObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.HSLA);
  }
  static toHSLA(t2, e2 = {}) {
    const s2 = ce.toHSLAObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.HSL(s2, r2);
  }
  static toHWBObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.HWB);
  }
  static toHWB(t2, e2 = {}) {
    const s2 = ce.toHWBObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.HWB(s2, r2);
  }
  static toHWBAObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.HWBA);
  }
  static toHWBA(t2, e2 = {}) {
    const s2 = ce.toHWBAObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.HWB(s2, r2);
  }
  static toCIELabObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.CIELab);
  }
  static toCIELab(t2, e2 = {}) {
    const s2 = ce.toCIELabObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.CIELab(s2, r2);
  }
  static toCIELabAObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.CIELabA);
  }
  static toCIELabA(t2, e2 = {}) {
    const s2 = ce.toCIELabAObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.CIELab(s2, r2);
  }
  static toLCHObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.LCH);
  }
  static toLCH(t2, e2 = {}) {
    const s2 = ce.toLCHObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.LCH(s2, r2);
  }
  static toLCHAObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.LCHA);
  }
  static toLCHA(t2, e2 = {}) {
    const s2 = ce.toLCHAObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.LCH(s2, r2);
  }
  static toCMYKObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.CMYK);
  }
  static toCMYK(t2, e2 = {}) {
    const s2 = ce.toCMYKObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.CMYK(s2, r2);
  }
  static toCMYKAObject(t2, e2 = {}) {
    const s2 = kt(t2);
    return se(t2, s2, e2.decimals, Qt.CMYKA);
  }
  static toCMYKA(t2, e2 = {}) {
    const s2 = ce.toCMYKAObject(t2, e2), r2 = Ot(e2, t2);
    return Tt.CMYK(s2, r2);
  }
  static getBlendHEXObject(t2, e2, s2 = 5) {
    return re(t2, e2, s2, 0, Qt.HEX);
  }
  static getBlendHEX(t2, e2, s2 = 5) {
    return ce.getBlendHEXObject(t2, e2, s2).map((t3) => Tt.HEX(t3));
  }
  static getBlendHEXAObject(t2, e2, s2 = 5) {
    return re(t2, e2, s2, 0, Qt.HEXA);
  }
  static getBlendHEXA(t2, e2, s2 = 5) {
    return ce.getBlendHEXAObject(t2, e2, s2).map((t3) => Tt.HEX(t3));
  }
  static getBlendRGBObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.RGB });
  }
  static getBlendRGB(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.RGB, cssFunction: Tt.RGB });
  }
  static getBlendRGBAObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.RGBA });
  }
  static getBlendRGBA(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.RGBA, cssFunction: Tt.RGB });
  }
  static getBlendHSLObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.HSL });
  }
  static getBlendHSL(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.HSL, cssFunction: Tt.HSL });
  }
  static getBlendHSLAObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.HSLA });
  }
  static getBlendHSLA(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.HSLA, cssFunction: Tt.HSL });
  }
  static getBlendHWBObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.HWB });
  }
  static getBlendHWB(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.HWB, cssFunction: Tt.HWB });
  }
  static getBlendHWBAObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.HWBA });
  }
  static getBlendHWBA(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.HWBA, cssFunction: Tt.HWB });
  }
  static getBlendCIELabObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.CIELab });
  }
  static getBlendCIELab(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.CIELab, cssFunction: Tt.CIELab });
  }
  static getBlendCIELabAObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.CIELabA });
  }
  static getBlendCIELabA(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.CIELabA, cssFunction: Tt.CIELab });
  }
  static getBlendLCHObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.LCH });
  }
  static getBlendLCH(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.LCH, cssFunction: Tt.LCH });
  }
  static getBlendLCHAObject(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.LCHA });
  }
  static getBlendLCHA(t2, e2, s2, r2) {
    return ae({ from: t2, to: e2, thirdParameter: s2, fourthParameter: r2, translateFunction: Qt.LCHA, cssFunction: Tt.LCH });
  }
  static getMixHEXObject(t2, e2 = g.ADDITIVE) {
    return te.HEX(t2, e2, false);
  }
  static getMixHEX(t2, e2 = g.ADDITIVE) {
    return te.HEX(t2, e2, true);
  }
  static getMixHEXAObject(t2, e2 = g.ADDITIVE) {
    return te.HEXA(t2, e2, false);
  }
  static getMixHEXA(t2, e2 = g.ADDITIVE) {
    return te.HEXA(t2, e2, true);
  }
  static getMixRGBObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.RGB, css: false });
  }
  static getMixRGB(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.RGB, css: true });
  }
  static getMixRGBAObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.RGBA, css: false });
  }
  static getMixRGBA(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.RGBA, css: true });
  }
  static getMixHSLObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.HSL, css: false });
  }
  static getMixHSL(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.HSL, css: true });
  }
  static getMixHSLAObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.HSLA, css: false });
  }
  static getMixHSLA(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.HSLA, css: true });
  }
  static getMixHWBObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.HWB, css: false });
  }
  static getMixHWB(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.HWB, css: true });
  }
  static getMixHWBAObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.HWBA, css: false });
  }
  static getMixHWBA(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.HWBA, css: true });
  }
  static getMixCIELabObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.CIELab, css: false });
  }
  static getMixCIELab(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.CIELab, css: true });
  }
  static getMixCIELabAObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.CIELabA, css: false });
  }
  static getMixCIELabA(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.CIELabA, css: true });
  }
  static getMixLCHObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.LCH, css: false });
  }
  static getMixLCH(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.LCH, css: true });
  }
  static getMixLCHAObject(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.LCHA, css: false });
  }
  static getMixLCHA(t2, e2, s2) {
    return ie({ colors: t2, secondParameter: e2, thirdParameter: s2, colorMixerFunction: oe.LCHA, css: true });
  }
  static getShades(t2, e2, s2) {
    return "number" == typeof e2 ? Zt(t2, e2, true, Ot(s2 || {}, t2)) : Zt(t2, 5, true, Ot(e2 || {}, t2));
  }
  static getTints(t2, e2, s2) {
    return "number" == typeof e2 ? Zt(t2, e2, false, Ot(s2 || {}, t2)) : Zt(t2, 5, false, Ot(e2 || {}, t2));
  }
  static getHarmony(t2, e2, s2, r2) {
    return `${e2}` in p ? ne(e2, t2, tt(s2) ? s2 : g.ADDITIVE, Ot(tt(s2) ? r2 || {} : s2 || {}, t2)) : tt(e2) ? ne(p.COMPLEMENTARY, t2, e2, Ot(s2 || {}, t2)) : ne(p.COMPLEMENTARY, t2, g.ADDITIVE, Ot(e2 || {}, t2));
  }
}
const le = { slots: { root: "data-[disabled]:opacity-75", picker: "flex gap-4", selector: "rounded-md touch-none", selectorBackground: "w-full h-full relative rounded-md", selectorThumb: "-translate-y-1/2 -translate-x-1/2 absolute size-4 ring-2 ring-(--color-white) rounded-full cursor-pointer data-[disabled]:cursor-not-allowed", track: "w-[8px] relative rounded-md touch-none", trackThumb: "absolute transform -translate-y-1/2 -translate-x-[4px] rtl:translate-x-[4px] size-4 rounded-full ring-2 ring-(--color-white) cursor-pointer data-[disabled]:cursor-not-allowed" }, variants: { size: { xs: { selector: "w-38 h-38", track: "h-38" }, sm: { selector: "w-40 h-40", track: "h-40" }, md: { selector: "w-42 h-42", track: "h-42" }, lg: { selector: "w-44 h-44", track: "h-44" }, xl: { selector: "w-46 h-46", track: "h-46" } } }, compoundVariants: [], defaultVariants: { size: "md" } };
function ue(t2) {
  const e2 = (200 - t2.s) * t2.v / 100;
  return { H: t2.h, S: 0 === e2 || 200 === e2 ? 0 : Math.round(t2.s * t2.v / (e2 <= 100 ? e2 : 200 - e2)), L: Math.round(e2 / 2) };
}
const he = { __name: "ColorPicker", __ssrInlineRender: true, props: Wt$1.mergeModels({ as: { type: null, required: false }, throttle: { type: Number, required: false, default: 50 }, disabled: { type: Boolean, required: false }, defaultValue: { type: String, required: false, default: "#FFFFFF" }, format: { type: String, required: false, default: "hex" }, size: { type: null, required: false }, class: { type: null, required: false }, ui: { type: null, required: false } }, { modelValue: { type: String }, modelModifiers: {} }), emits: ["update:modelValue"], setup(t2) {
  const c2 = t2, u2 = Wt$1.useModel(t2, "modelValue", { type: String }), h2 = da(), d2 = Wt$1.computed(() => {
    var t3;
    return Ky({ extend: Ky(le), ...(null == (t3 = h2.ui) ? void 0 : t3.colorPicker) || {} })({ size: c2.size });
  }), m2 = Wt$1.computed({ get() {
    try {
      return function(t3) {
        const e2 = t3.S * (t3.L < 50 ? t3.L : 100 - t3.L), s2 = t3.L + e2 / 100;
        return { h: t3.H, s: 0 === t3.L ? t3.S : 2 * e2 / s2, v: s2 };
      }(new ce(u2.value || c2.defaultValue).HSLObject);
    } catch (t3) {
      return { h: 0, s: 0, v: 100 };
    }
  }, set(t3) {
    const e2 = new ce(ue(t3), { decimals: 2, labUnit: "percent", cmykUnit: "percent", cmykFunction: "cmyk" });
    switch (c2.format) {
      case "rgb":
        u2.value = e2.RGB;
        break;
      case "hsl":
        u2.value = e2.HSL;
        break;
      case "cmyk":
        u2.value = e2.CMYK;
        break;
      case "lab":
        u2.value = e2.CIELab;
        break;
      default:
        u2.value = e2.HEX;
    }
  } });
  function A2(t3, s2, r2 = "both", a2 = { x: 0, y: 0 }, i2) {
    const n2 = Wt$1.ref(a2);
    return Wt$1.ref(), m$1(t3), m$1(s2), { position: n2 };
  }
  function b2(t3, e2 = "left") {
    return "right" === e2 ? 100 * t3 / 360 : t3 / 100 * 360;
  }
  function p2(t3) {
    return 100 - t3;
  }
  const g2 = Wt$1.ref(null), H2 = Wt$1.ref(null), C2 = Wt$1.ref(null), L2 = Wt$1.ref(null), B2 = Wt$1.computed(() => c2.disabled), { position: E2 } = A2(H2, g2, "both", { x: m2.value.s, y: p2(m2.value.v) }), { position: f2 } = A2(L2, C2, "y", { x: 0, y: b2(m2.value.h, "right") }), { pause: F2, resume: R2 } = Xm(m2, (t3) => {
    E2.value = { x: t3.s, y: p2(t3.v) }, f2.value = { x: 0, y: b2(t3.h, "right") };
  });
  Ym([E2, f2], () => {
    F2(), m2.value = { h: b2(f2.value.y), s: E2.value.x, v: p2(E2.value.y) }, Wt$1.nextTick(R2);
  }, { throttle: () => c2.throttle });
  const _2 = Wt$1.computed(() => new ce(ue({ h: b2(f2.value.y), s: 100, v: 100 })).HEX), S2 = Wt$1.computed(() => ({ backgroundColor: _2.value })), y2 = Wt$1.computed(() => ({ backgroundColor: new ce(u2.value || c2.defaultValue).HEX, left: `${E2.value.x}%`, top: `${E2.value.y}%` })), v2 = Wt$1.computed(() => ({ backgroundColor: _2.value, top: `${f2.value.y}%` }));
  return (s2, r2, a2, i2) => {
    var l2;
    r2(pm.ssrRenderComponent(Wt$1.unref(_m), Wt$1.mergeProps({ as: t2.as, class: d2.value.root({ class: [null == (l2 = c2.ui) ? void 0 : l2.root, c2.class] }), "data-disabled": !!B2.value || void 0 }, i2), { default: Wt$1.withCtx((t3, s3, r3, a3) => {
      var i3, o2, l3, u3, h3, m3, A3, b3, p3, E3, f3, F3;
      if (!s3) return [Wt$1.createVNode("div", { class: d2.value.picker({ class: null == (A3 = c2.ui) ? void 0 : A3.picker }) }, [Wt$1.createVNode("div", { ref_key: "selectorRef", ref: g2, class: d2.value.selector({ class: null == (b3 = c2.ui) ? void 0 : b3.selector }), style: S2.value }, [Wt$1.createVNode("div", { class: d2.value.selectorBackground({ class: null == (p3 = c2.ui) ? void 0 : p3.selectorBackground }), "data-color-picker-background": "" }, [Wt$1.createVNode("div", { ref_key: "selectorThumbRef", ref: H2, class: d2.value.selectorThumb({ class: null == (E3 = c2.ui) ? void 0 : E3.selectorThumb }), style: y2.value, "data-disabled": !!B2.value || void 0 }, null, 14, ["data-disabled"])], 2)], 6), Wt$1.createVNode("div", { ref_key: "trackRef", ref: C2, class: d2.value.track({ class: null == (f3 = c2.ui) ? void 0 : f3.track }), "data-color-picker-track": "" }, [Wt$1.createVNode("div", { ref_key: "trackThumbRef", ref: L2, class: d2.value.trackThumb({ class: null == (F3 = c2.ui) ? void 0 : F3.trackThumb }), style: v2.value, "data-disabled": !!B2.value || void 0 }, null, 14, ["data-disabled"])], 2)], 2)];
      s3(`<div class="${pm.ssrRenderClass(d2.value.picker({ class: null == (i3 = c2.ui) ? void 0 : i3.picker }))}" data-v-2f14ca51${a3}><div class="${pm.ssrRenderClass(d2.value.selector({ class: null == (o2 = c2.ui) ? void 0 : o2.selector }))}" style="${pm.ssrRenderStyle(S2.value)}" data-v-2f14ca51${a3}><div class="${pm.ssrRenderClass(d2.value.selectorBackground({ class: null == (l3 = c2.ui) ? void 0 : l3.selectorBackground }))}" data-color-picker-background data-v-2f14ca51${a3}><div class="${pm.ssrRenderClass(d2.value.selectorThumb({ class: null == (u3 = c2.ui) ? void 0 : u3.selectorThumb }))}" style="${pm.ssrRenderStyle(y2.value)}"${pm.ssrRenderAttr("data-disabled", !!B2.value || void 0)} data-v-2f14ca51${a3}></div></div></div><div class="${pm.ssrRenderClass(d2.value.track({ class: null == (h3 = c2.ui) ? void 0 : h3.track }))}" data-color-picker-track data-v-2f14ca51${a3}><div class="${pm.ssrRenderClass(d2.value.trackThumb({ class: null == (m3 = c2.ui) ? void 0 : m3.trackThumb }))}" style="${pm.ssrRenderStyle(v2.value)}"${pm.ssrRenderAttr("data-disabled", !!B2.value || void 0)} data-v-2f14ca51${a3}></div></div></div>`);
    }), _: 1 }, a2));
  };
} }, de = he.setup;
he.setup = (t2, s2) => {
  const r2 = Wt$1.useSSRContext();
  return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("../node_modules/@nuxt/ui/dist/runtime/components/ColorPicker.vue"), de ? de(t2, s2) : void 0;
};
const me = o(he, [["__scopeId", "data-v-2f14ca51"]]), Ae = Wt$1.defineComponent({ __name: "ColorPickerField", __ssrInlineRender: true, props: { modelValue: { type: String, default: "#000000" }, format: { type: String, default: "hex" }, size: { type: String, default: "md" }, disabled: { type: Boolean, default: false }, as: { type: String, default: "div" }, ui: { type: Object, default: () => ({}) }, label: { type: String, default: "Select Color" } }, emits: ["update:modelValue"], setup(s2, { emit: r2 }) {
  const a2 = r2, i2 = s2, o2 = Wt$1.computed(() => ({ backgroundColor: i2.modelValue, border: `1px solid ${i2.modelValue}` })), l2 = Wt$1.ref(i2.modelValue);
  return (s3, r3, u2, h2) => {
    const d2 = fn, m2 = Ob, A2 = me;
    r3(pm.ssrRenderComponent(d2, h2, { content: Wt$1.withCtx((t2, s4, r4, o3) => {
      if (!s4) return [Wt$1.createVNode(A2, { modelValue: Wt$1.unref(l2), "onUpdate:modelValue": [(t3) => Wt$1.isRef(l2) ? l2.value = t3 : null, (t3) => a2("update:modelValue", t3)], class: "p-2", format: i2.format, size: i2.size, disabled: i2.disabled, as: i2.as, label: i2.label, ui: i2.ui }, null, 8, ["modelValue", "onUpdate:modelValue", "format", "size", "disabled", "as", "label", "ui"])];
      s4(pm.ssrRenderComponent(A2, { modelValue: Wt$1.unref(l2), "onUpdate:modelValue": [(t3) => Wt$1.isRef(l2) ? l2.value = t3 : null, (t3) => a2("update:modelValue", t3)], class: "p-2", format: i2.format, size: i2.size, disabled: i2.disabled, as: i2.as, label: i2.label, ui: i2.ui }, null, r4, o3));
    }), default: Wt$1.withCtx((t2, s4, r4, a3) => {
      if (!s4) return [Wt$1.createVNode(m2, { label: i2.label, color: "neutral", variant: "outline" }, { trailing: Wt$1.withCtx(() => [Wt$1.createVNode("span", { style: Wt$1.unref(o2), class: "size-3 rounded-full" }, null, 4)]), _: 1 }, 8, ["label"])];
      s4(pm.ssrRenderComponent(m2, { label: i2.label, color: "neutral", variant: "outline" }, { trailing: Wt$1.withCtx((t3, s5, r5, a4) => {
        if (!s5) return [Wt$1.createVNode("span", { style: Wt$1.unref(o2), class: "size-3 rounded-full" }, null, 4)];
        s5(`<span style="${pm.ssrRenderStyle(Wt$1.unref(o2))}" class="size-3 rounded-full"${a4}></span>`);
      }), _: 1 }, r4, a3));
    }), _: 1 }, u2));
  };
} }), be = Ae.setup;
Ae.setup = (t2, s2) => {
  const r2 = Wt$1.useSSRContext();
  return (r2.modules || (r2.modules = /* @__PURE__ */ new Set())).add("components/ui/ColorPickerField.vue"), be ? be(t2, s2) : void 0;
};

export { Ae as default };
//# sourceMappingURL=ColorPickerField-CRNVMCCM.mjs.map
